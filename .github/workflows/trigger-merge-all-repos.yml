# .github/workflows/trigger_merge_all_repos.yml
name: 💿 Trigger Merge Main to Pre-Prod for All Repos

on:
  workflow_dispatch:
    inputs:
      repos_to_update:
        description: 'Comma-separated list of specific repositories to update (e.g., repo-a,repo-b). Leave empty for all listed below.'
        required: false
        default: ''
      skip_confirmation:
        description: 'Check to skip manual confirmation for large operations. Use with caution!'
        type: boolean
        default: false

jobs:
  define_and_trigger_merges:
    runs-on: ubuntu-latest
    outputs:
      repos_json: ${{ steps.all_repos_list.outputs.repos_json }} # Exponer la salida JSON

    steps:
    - name: Define All Repositories
      id: all_repos_list
      run: |
        # Lista de todos los repositorios de tu organización
        # Asegúrate de que los nombres de los repositorios estén en formato "organizacion/nombre-del-repo"
        ALL_ORG_REPOS=(
          "futbolemotion/superadmin"
        )

        REPOS_ARRAY=()
        if [ -n "${{ github.event.inputs.repos_to_update }}" ]; then
          IFS=',' read -ra SELECTED_INPUT_REPOS <<< "${{ github.event.inputs.repos_to_update }}"
          for selected_repo_short_name in "${SELECTED_INPUT_REPOS[@]}"; do
            REPO_MATCH_FOUND=false
            for full_repo_name in "${ALL_ORG_REPOS[@]}"; do
              if [[ "$full_repo_name" == *"/${selected_repo_short_name}" ]]; then # Matches by short name
                REPOS_ARRAY+=("$full_repo_name")
                REPO_MATCH_FOUND=true
                break
              fi
            done
            if [ "$REPO_MATCH_FOUND" = false ]; then
              echo "::warning::Repository '$selected_repo_short_name' not found in the predefined list. Skipping."
            fi
          done
        else
          REPOS_ARRAY=("${ALL_ORG_REPOS[@]}")
        fi
        
        # Convertir el array de bash a un string JSON válido
        # Utilizamos jq para un manejo robusto de JSON. Aseguramos que la salida sea un array JSON.
        JSON_REPOS=$(printf '%s\n' "${REPOS_ARRAY[@]}" | jq -R . | jq -s .)
        
        echo "repos_json=$JSON_REPOS" >> $GITHUB_OUTPUT
        echo "::notice::Repositories to process: $JSON_REPOS" # Log para depuración
      shell: bash

    - name: Confirm Operation (if not skipped)
      if: github.event.inputs.skip_confirmation == false
      run: |
        # Usamos jq para pretty-print el JSON para la confirmación
        echo "You are about to merge 'main' into 'pre_prod' for the following repositories:"
        echo "${{ steps.all_repos_list.outputs.repos_json }}" | jq -r '.[] | "- " + .'
        echo ""
        echo "To proceed, you must manually approve this step."
        echo "If you want to skip this confirmation for future runs, check 'Skip confirmation' when triggering."
        exit 1 # This will cause the workflow to fail unless manually approved in the UI
      shell: bash

  # Este job se crea dinámicamente para cada repositorio
  trigger_merge_for_each_repo:
    needs: [define_and_trigger_merges] # Depende del job que define la lista de repos
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Ahora, repos_json ya es un array JSON válido, podemos usar fromJson directamente.
        repository: ${{ fromJson(needs.define_and_trigger_merges.outputs.repos_json) }}
    name: Merging ${{ matrix.repository }}
    uses: .github/workflows/merge-main-to-pre-prod-reusable.yml # Referencia al workflow reusable
    with:
      target_repo: ${{ matrix.repository }}
      source_branch: 'main'
      target_branch: 'pre_prod'
    secrets:
      ORG_REPO_UPDATE_PAT: ${{ secrets.ORG_REPO_UPDATE_PAT }} # Pasa el secreto de la organización